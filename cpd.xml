<?xml version="1.0" encoding="UTF-8"?>
<pmd-cpd>
<duplication lines="24" tokens="194">
<file line="127" path="/home/jan/DB/MapDB/src/main/java/org/mapdb/Fun.java"/>
<file line="200" path="/home/jan/DB/MapDB/src/main/java/org/mapdb/Fun.java"/>
<codefragment>
<![CDATA[
            final Tuple3 oo = (Tuple3) o;
            if(a!=oo.a){
                if(a==null || oo.a==HI) return -1;
                if(a==HI ||  oo.a==null) return 1;

                final int c = ((Comparable)a).compareTo(oo.a);
                if(c!=0) return c;
            }

            if(b!=oo.b){
                if(b==null || oo.b==HI) return -1;
                if(b==HI || oo.b==null) return 1;

                final int i = ((Comparable)b).compareTo(oo.b);
                if(i!=0) return i;
            }

            if(c!=oo.c){
                if(c==null || oo.c==HI) return -1;
                if(c==HI || oo.c==null) return 1;

                final int i = ((Comparable)c).compareTo(oo.c);
                if(i!=0) return i;
            }
]]>
</codefragment>
</duplication>
<duplication lines="40" tokens="172">
<file line="223" path="/home/jan/DB/MapDB/src/main/java/org/mapdb/StoreWAL.java"/>
<file line="280" path="/home/jan/DB/MapDB/src/main/java/org/mapdb/StoreWAL.java"/>
<codefragment>
<![CDATA[
            final long[] physPos;
            final long[] logPos;

            long indexVal = 0;
            long[] linkedRecords = getLinkedRecordsFromLog(ioRecid);
            if(linkedRecords==null){
                indexVal = index.getLong(ioRecid);
                linkedRecords = getLinkedRecordsIndexVals(indexVal);
            }

            structuralLock.lock();
            try{
                openLogIfNeeded();

                //free first record pointed from indexVal
                if(indexVal!=0)
                    freePhysPut(indexVal);

                //if there are more linked records, free those as well
                if(linkedRecords!=null){
                    for(int i=0; i<linkedRecords.length &&linkedRecords[i]!=0;i++){
                        freePhysPut(linkedRecords[i]);
                    }
                }


                //first get space in phys
                physPos = physAllocate(out.pos,false);
                //now get space in log
                logPos = logAllocate(physPos);

            }finally{
                structuralLock.unlock();
            }

            //write data into log
            walIndexVal((logPos[0]&MASK_OFFSET) - 1-8-8-1-8, ioRecid, physPos[0]);
            walPhysArray(out, physPos, logPos);

            modified.put(ioRecid,logPos);
]]>
</codefragment>
</duplication>
<duplication lines="29" tokens="161">
<file line="2133" path="/home/jan/DB/MapDB/src/main/java/org/mapdb/BTreeMap.java"/>
<file line="1178" path="/home/jan/DB/MapDB/src/main/java/org/mapdb/HTreeMap.java"/>
<codefragment>
<![CDATA[
        return new BTreeMap<K, V>(snapshot,treeRecid, defaultSerializer);
    }



    protected final Object modListenersLock = new Object();
    protected Bind.MapListener<K,V>[] modListeners = new Bind.MapListener[0];

    @Override
    public void addModificationListener(Bind.MapListener<K,V> listener) {
        synchronized (modListenersLock){
            Bind.MapListener<K,V>[] modListeners2 =
                    Arrays.copyOf(modListeners,modListeners.length+1);
            modListeners2[modListeners2.length-1] = listener;
            modListeners = modListeners2;
        }

    }

    @Override
    public void removeModificationListener(Bind.MapListener<K,V> listener) {
        synchronized (modListenersLock){
            for(int i=0;i<modListeners.length;i++){
                if(modListeners[i]==listener) modListeners[i]=null;
            }
        }
    }

    protected void notify(K key, V oldValue, V newValue) {
]]>
</codefragment>
</duplication>
<duplication lines="21" tokens="155">
<file line="1012" path="/home/jan/DB/MapDB/src/main/java/org/mapdb/BTreeMap.java"/>
<file line="1061" path="/home/jan/DB/MapDB/src/main/java/org/mapdb/BTreeMap.java"/>
<codefragment>
<![CDATA[
        long rootRecid = engine.get(rootRecidRef, Serializer.LONG_SERIALIZER);
        long current = rootRecid;
        BNode node = engine.get(current, nodeSerializer);
        //dive until leaf is found
        while(!node.isLeaf()){
            current = nextDir((DirNode) node, key);
            node = engine.get(current, nodeSerializer);
        }

        Utils.lock(nodeLocks, current);
        LeafNode leaf = (LeafNode) engine.get(current, nodeSerializer);

        int pos = findChildren(key, node.keys());
        while(pos==leaf.keys.length){
            //follow leaf link until necessary
            Utils.lock(nodeLocks, leaf.next);
            Utils.unlock(nodeLocks, current);
            current = leaf.next;
            leaf = (LeafNode) engine.get(current, nodeSerializer);
            pos = findChildren(key, node.keys());
        }
]]>
</codefragment>
</duplication>
<duplication lines="16" tokens="130">
<file line="70" path="/home/jan/DB/MapDB/src/main/java/org/mapdb/Fun.java"/>
<file line="127" path="/home/jan/DB/MapDB/src/main/java/org/mapdb/Fun.java"/>
<file line="200" path="/home/jan/DB/MapDB/src/main/java/org/mapdb/Fun.java"/>
<codefragment>
<![CDATA[
            final Tuple2 oo = (Tuple2) o;
            if(a!=oo.a){
                if(a==null || oo.a==HI) return -1;
                if(a==HI || oo.a==null) return 1;

                final int c = ((Comparable)a).compareTo(oo.a);
                if(c!=0) return c;
            }

            if(b!=oo.b){
                if(b==null || oo.b==HI) return -1;
                if(b==HI || oo.b==null) return 1;

                final int i = ((Comparable)b).compareTo(oo.b);
                if(i!=0) return i;
            }
]]>
</codefragment>
</duplication>
<duplication lines="21" tokens="127">
<file line="1486" path="/home/jan/DB/MapDB/src/main/java/org/mapdb/BTreeMap.java"/>
<file line="1631" path="/home/jan/DB/MapDB/src/main/java/org/mapdb/BTreeMap.java"/>
<codefragment>
<![CDATA[
                return ((BTreeMap.SubMap<E,Object>)m).keyIterator();
        }
        @Override
		public boolean equals(Object o) {
            if (o == this)
                return true;
            if (!(o instanceof Set))
                return false;
            Collection<?> c = (Collection<?>) o;
            try {
                return containsAll(c) && c.containsAll(this);
            } catch (ClassCastException unused)   {
                return false;
            } catch (NullPointerException unused) {
                return false;
            }
        }
        @Override
		public Object[] toArray()     { return toList(this).toArray();  }
        @Override
		public <T> T[] toArray(T[] a) { return toList(this).toArray(a); }
]]>
</codefragment>
</duplication>
<duplication lines="14" tokens="122">
<file line="653" path="/home/jan/DB/MapDB/src/main/java/org/mapdb/LongConcurrentLRUMap.java"/>
<file line="681" path="/home/jan/DB/MapDB/src/main/java/org/mapdb/LongConcurrentLRUMap.java"/>
<codefragment>
<![CDATA[
  public Map<Long,V> getOldestAccessedItems(int n) {
    Map<Long,V> result = new LinkedHashMap<Long,V>();
    if (n <= 0)
      return result;
    TreeSet<CacheEntry<V>> tree = new TreeSet<CacheEntry<V>>();
    markAndSweepLock.lock();
    try {
        for( Iterator<CacheEntry<V>> iter = map.valuesIterator(); iter.hasNext();){
        CacheEntry<V> ce = iter.next();
        ce.lastAccessedCopy = ce.lastAccessed;
        if (tree.size() < n) {
          tree.add(ce);
        } else {
          if (ce.lastAccessedCopy < tree.first().lastAccessedCopy) {
]]>
</codefragment>
</duplication>
<duplication lines="3" tokens="121">
<file line="72" path="/home/jan/DB/MapDB/src/main/java/org/mapdb/EncryptionXTEA.java"/>
<file line="95" path="/home/jan/DB/MapDB/src/main/java/org/mapdb/EncryptionXTEA.java"/>
<codefragment>
<![CDATA[
    private void encryptBlock(byte[] in, byte[] out, int off) {
        int y = (in[off] << 24) | ((in[off+1] & 255) << 16) | ((in[off+2] & 255) << 8) | (in[off+3] & 255);
        int z = (in[off+4] << 24) | ((in[off+5] & 255) << 16) | ((in[off+6] & 255) << 8) | (in[off+7] & 255);
]]>
</codefragment>
</duplication>
<duplication lines="5" tokens="118">
<file line="91" path="/home/jan/DB/MapDB/src/main/java/org/mapdb/EncryptionXTEA.java"/>
<file line="114" path="/home/jan/DB/MapDB/src/main/java/org/mapdb/EncryptionXTEA.java"/>
<codefragment>
<![CDATA[
        out[off] = (byte) (y >> 24); out[off+1] = (byte) (y >> 16); out[off+2] = (byte) (y >> 8); out[off+3] = (byte) y;
        out[off+4] = (byte) (z >> 24); out[off+5] = (byte) (z >> 16); out[off+6] = (byte) (z >> 8); out[off+7] = (byte) z;
    }

    private void decryptBlock(byte[] in, byte[] out, int off) {
]]>
</codefragment>
</duplication>
<duplication lines="22" tokens="113">
<file line="1125" path="/home/jan/DB/MapDB/src/main/java/org/mapdb/BTreeMap.java"/>
<file line="1885" path="/home/jan/DB/MapDB/src/main/java/org/mapdb/BTreeMap.java"/>
<codefragment>
<![CDATA[
    }


    @Override
    public Entry<K, V> pollFirstEntry() {
        while(true){
            Entry<K, V> e = firstEntry();
            if(e==null || remove(e.getKey(),e.getValue())){
                return e;
            }
        }
    }

    @Override
    public Entry<K, V> pollLastEntry() {
        while(true){
            Entry<K, V> e = lastEntry();
            if(e==null || remove(e.getKey(),e.getValue())){
                return e;
            }
        }
    }
]]>
</codefragment>
</duplication>
<duplication lines="21" tokens="107">
<file line="236" path="/home/jan/DB/MapDB/src/main/java/org/mapdb/StoreAppend.java"/>
<file line="275" path="/home/jan/DB/MapDB/src/main/java/org/mapdb/StoreAppend.java"/>
<codefragment>
<![CDATA[
            long pos;
            long volNum;
            Volume vol;
            structuralLock.lock();
            try{
                pos = currentFileOffset;
                currentFileOffset += 8 + 4 + out.pos;
                currentVolume.ensureAvailable(currentFileOffset);
                volNum = currentVolumeNum;
                vol = currentVolume;
                rollOverFile();
            }finally {
                structuralLock.unlock();
            }
            vol.putLong(pos, recid);
            pos+=8;
            long filePos = (volNum<<FILE_NUMBER_SHIFT) | pos;
            vol.putInt(pos,out.pos);
            pos+=4;
            vol.putData(pos,out.buf, 0, out.pos);
            recidsInTx.put(recid, filePos);
]]>
</codefragment>
</duplication>
<duplication lines="27" tokens="104">
<file line="253" path="/home/jan/DB/MapDB/src/main/java/org/mapdb/StoreDirect.java"/>
<file line="262" path="/home/jan/DB/MapDB/src/main/java/org/mapdb/StoreWAL.java"/>
<codefragment>
<![CDATA[
            put2(out, ioRecid, indexVals);
        }finally{
            Utils.writeUnlock(locks, recid);
        }
    }

    @Override
    public <A> boolean compareAndSwap(long recid, A expectedOldValue, A newValue, Serializer<A> serializer) {
        final long ioRecid = IO_USER_START + recid*8;
        Utils.writeLock(locks, recid);
        try{
            /*
             * deserialize old value
             */

            A oldVal = get2(ioRecid,serializer);

            /*
             * compare oldValue and expected
             */
            if((oldVal == null && expectedOldValue!=null) || (oldVal!=null && !oldVal.equals(expectedOldValue)))
                return false;

            /*
             * write new value
             */
            DataOutput2 out = serialize(newValue, serializer);
]]>
</codefragment>
</duplication>
</pmd-cpd>